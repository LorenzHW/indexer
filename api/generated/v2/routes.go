// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"round":                 true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"i4Zf3MjRL+7U3/x68/8CAAD//2+k7bAOFAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
